\documentclass{article}

\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{ebproof}
\usepackage{xcolor}

\newcommand{\evalsto}{\mathrel{\mathop{\Downarrow}}}
\newcommand{\matches}{\mathrel{\mathop{\sim}}}
\newcommand{\hooksto}{\mathrel{\mathop{\hookrightarrow}}}
\newcommand{\entails}{\mathrel{\mathop{\vdash}}}
\newcommand{\steps}{\mathrel{\mathop{\vartriangleright}}}
\newcommand{\skips}{\mathrel{\mathop{\blacktriangleright}}}
\newcommand{\final}{~\mathbf{final}}
\newcommand{\ival}{~\mathbf{value}}
\newcommand{\indet}{~\mathbf{indet}}
\newcommand{\istep}{~\mathbf{step}}
\newcommand{\iskip}{~\mathbf{skip}}
\newcommand{\class}[1]{\operatorname{#1}}
\DeclareMathOperator{\Filter}{Filter}
\DeclareMathOperator{\fskip}{\mathsf{skip}}
\DeclareMathOperator{\fstep}{\mathsf{step}}
\newcommand{\fin}{\mathrel{\mathop{\mathsf{in}}}}
\newcommand{\flet}{\operatorname{\mathsf{let}}}
\newcommand{\synth}{\mathrel{\mathop{\Rightarrow}}}
\newcommand{\analyze}{\mathrel{\mathop{\Leftarrow}}}
\newcommand{\ctype}[1]{\mathsf{#1}}
\newcommand{\inl}{\operatorname{\mathsf{injL}}}
\newcommand{\inr}{\operatorname{\mathsf{injR}}}
\newcommand{\prl}{\operatorname{\mathsf{prjL}}}
\newcommand{\prr}{\operatorname{\mathsf{prjR}}}
\newcommand{\MatchArrow}{\mathrel{\mathop{\blacktriangleright_{\rightarrow}}}}
\newcommand{\fif}{\operatorname{\mathsf{if}}}
\newcommand{\fthen}{\mathrel{\mathop{\mathsf{then}}}}
\newcommand{\felse}{\mathrel{\mathop{\mathsf{else}}}}
\newcommand{\fcase}{\operatorname{\mathsf{case}}}
\newcommand{\fcaseL}{\mathsf{L}}
\newcommand{\fcaseR}{\mathsf{R}}

\begin{document}

\section{Environment-based Evaluation Filter}

\begin{enumerate}
  \item \fbox{\(\class{Expression} d\)} Expression.
    \[
      \begin{array}{rcll}
        \class{Expression} d
        &\coloneqq& @ & \text{(Hole)} \\
        &\mid& x & \text{(Variable)} \\
        &\mid& \lambda x . d & \text{(Function)} \\
        &\mid& [\sigma] d & \text{(Closure)} \\
        &\mid& d (d) & \text{(Application)} \\
        &\mid& \flet x = d_1 \fin d_2 & \text{(Let Expression)}\\
        &\mid& Y (\lambda x . d) & \text{(Fix Point)}\\
        &\mid& \class{Number} \underline{n} & \text{(Number)} \\
        &\mid& d + d & \text{(Addition)} \\
        &\mid& d \times d & \text{(Multiplication)} \\
        &\mid& \mathsf{true} \mid \mathsf{false} & \text{(Boolean)} \\
        &\mid& \fif d_1 \fthen d_2 \felse d_3 & \text{(If-Then-Else)} \\
        &\mid& (d, d) & \text{(Product)} \\
        &\mid& \prl d \mid \prr d & \text{(Projection)} \\
        &\mid& \inl d \mid \inr d & \text{(Injection)} \\
        &\mid& \fcase d_1 \fcaseL x . d_2 \fcaseR x . d_3 & \text{(Case Analyzation)} \\
        &\mid& \fskip f \fin d & \text{(Skip)}\\
        &\mid& \fstep f \fin d & \text{(Step)}
      \end{array}
    \]

  \item \fbox{\(\class{Type} \tau\)} Type \(\tau\)
    \[
      \begin{array}{rcl}
        \class{Type} \tau
        &\coloneqq& \ctype{Number}\\
        &\mid& \ctype{Boolean}\\
        &\mid& \ctype{\tau \to \tau}\\
        &\mid& \ctype{\tau \times \tau}\\
        &\mid& \ctype{\tau + \tau}\\
        &\mid& \ctype{?}
      \end{array}
    \]
  \item \fbox{\(f\)} Filter.
    \[
      \begin{array}{rcll}
        \class{Filter} f
        &\coloneqq& \ast & \text{(Wildcard)}\\
        &\mid& x & \text{(Variable)}\\
        &\mid& \lambda x . f & \text{(Function)}\\
        &\mid& f(f) & \text{(Application)}\\
        &\mid& \flet x = d_1 \fin d_2 & \text{(Let Expression)}\\
        &\mid& Y (\lambda x . d) & \text{(Fix Point)}\\
        &\mid& \class{Number} \underline{n} & \text{(Number)}\\
        &\mid& f + f & \text{(Addition)} \\
        &\mid& f \times f & \text{(Multiplication)}
      \end{array}
    \]
  \item \fbox{\(\Gamma \entails d \synth T\)} Expression \(d\)
    synthesized to type \(T\).

    \fbox{\(\Gamma \entails d \analyze T\)} Expression \(d\) is analyzed
    against type \(T\).
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d \synth \tau}
        \infer1[]{\Gamma \entails d \analyze \tau}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[]{\Gamma \entails @ \synth \ctype{?}}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[]{\Gamma \entails \underline{n} \synth \ctype{Number}}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[]{\Gamma \entails \mathsf{true} \synth \ctype{Boolean}}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[]{\Gamma \entails \mathsf{false} \synth \ctype{Boolean}}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma, x : \tau_1 \entails d \synth \tau_2}
        \infer1[]{\Gamma \entails \lambda x : \tau_1 . d \synth \tau_1 \to \tau_2}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth \tau}
        \hypo{\tau \MatchArrow \tau_1 \to \tau_2}
        \hypo{\Gamma \entails d_2 \analyze \tau_1}
        \infer3[]{\Gamma \entails d_1(d_2) \synth \tau_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth \tau_1}
        \hypo{\Gamma \entails d_2 \synth \tau_2}
        \infer2[]{\Gamma \entails (d_1, d_2) \synth \tau_1 \times \tau_2}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d \analyze \tau_1}
        \infer1[]{\Gamma \entails \inl d \analyze \tau_1 + \tau_2}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d \analyze \tau_2}
        \infer1[]{\Gamma \entails \inr d \analyze \tau_1 + \tau_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \analyze \tau_1 + \tau_2}
        \hypo{\Gamma, x : \tau_1 \entails d_2 \synth \tau}
        \hypo{\Gamma, x : \tau_2 \entails d_3 \analyze \tau}
        \infer3[]{\Gamma \entails \fcase d_1 \fcaseL x . d_2 \fcaseR x . d_3 \synth \tau}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \analyze \ctype{Boolean}}
        \hypo{\Gamma \entails d_2 \synth \tau}
        \hypo{\Gamma \entails d_3 \analyze \tau}
        \infer3[]{\Gamma \entails \fif d_1 \fthen d_2 \felse d_3 \synth \tau}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth \tau_1}
        \hypo{\Gamma \entails d_2 \synth \tau_2}
        \infer2[]{\Gamma \entails (d_1, d_2) \synth \tau_1 \times
        \tau_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth \tau_1 \times \tau_2}
        \infer1[]{\Gamma \entails \prl d_1 \synth \tau_1}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth \tau_1 \times \tau_2}
        \infer1[]{\Gamma \entails \prr d_1 \synth \tau_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d \synth T}
        \infer1[]{\Gamma \entails \fstep f \fin d \synth T}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d \synth T}
        \infer1[]{\Gamma \entails \fskip f \fin d \synth T}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d \analyze T}
        \infer1[]{\Gamma \entails \fstep f \fin d \analyze T}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\Gamma \entails d \analyze T}
        \infer1[]{\Gamma \entails \fskip f \fin d \analyze T}
      \end{prooftree}
    \]
  \item \fbox{\(d \final\)} Expression \(d\) is in its normal form. 

    \fbox{\(d \indet\)} Expression \(d\) is incomplete, and in its normal form.

    \fbox{\(d \ival\)} Expression \(d\) is a value.
    \[
      \begin{prooftree}
        \infer0[(FV-Fun)]{[\sigma] \lambda x . d \ival}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[(FV-Num)]{\underline{n} \ival}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[(FI-Hole)]{@ \indet}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{x \notin \sigma}
        \infer1[(FI-Var)]{\sigma \entails x \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \indet}
        \infer1[(FI-Ap-L)]{\sigma \entails d_1 (d_2) \indet}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d_2 \indet}
        \infer1[(FI-Ap-R)]{\sigma \entails d_1 (d_2) \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \indet}
        \infer1[(FI-Let)]{\sigma \entails \flet x = d_1 \fin d_2 \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \indet}
        \infer1[(FI-Add-L)]{\sigma \entails d_1 + d_2 \indet}
      \end{prooftree}
      \begin{prooftree}
        \hypo{\sigma \entails d_2 \indet}
        \infer1[(FI-Add-R)]{\sigma \entails d_1 + d_2 \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \indet}
        \infer1[(FI-Mul-L)]{\sigma \entails d_1 \times d_2 \indet}
      \end{prooftree}
      \begin{prooftree}
        \hypo{\sigma \entails d_2 \indet}
        \infer1[(FI-Mul-R)]{\sigma \entails d_1 \times d_2 \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d \indet}
        \infer1[(FI-Skip)]{\sigma \entails \fskip f \fin d \indet}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d \indet}
        \infer1[(FI-Step)]{\sigma \entails \fstep f \fin d \indet}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{d \ival}
        \infer1[(FV)]{\sigma \entails d \final}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d \indet}
        \infer1[(FI)]{\sigma \entails d \final}
      \end{prooftree}
    \]
  \item \fbox{\(d \evalsto v\)} Expression \(d\) evaluates to expression \(v\).
    \[
      \begin{prooftree}
        \hypo{d \final}
        \infer1[(EV-Final)]{d \evalsto d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{x \hooksto d \in \sigma}
        \infer1[(EV-Var)]{\sigma \entails x \evalsto d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[(EV-Fun)]{\sigma \entails \lambda x . d \evalsto [\sigma] (\lambda x . d)}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma' \entails d \evalsto v}
        \infer1[(EV-Closure)]{\sigma \entails [\sigma'] d \evalsto v}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{d_1 \evalsto [\sigma'] (\lambda x . d_3)}
        \hypo{d_2 \evalsto v_2 \ival}
        \hypo{\sigma', x \hooksto v_2 \entails d_3 \evalsto d_3'}
        \infer3[(EV-Ap)]{\sigma \entails d_1 (d_2) \evalsto d_3'}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma, x \hooksto Y (\lambda x . d) \entails d \evalsto v}
        \infer1[(EV-Fix)]{\sigma \entails Y (\lambda x . d) \evalsto v}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{d_1 \evalsto v_1}
        \hypo{\sigma, x \hooksto v_1 \entails d_2 \evalsto v_2}
        \infer2[(EV-Let)]{
          \sigma \entails\flet x = d_1 \fin d_2
          \evalsto
          v_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_0 \evalsto \mathsf{true}}
        \hypo{\sigma \entails d_1 \evalsto v_1}
        \infer2[(EV-If-T)]{
          \sigma \entails
          \fif d_0 \fthen d_1 \felse d_2 \evalsto v_1
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_0 \evalsto \mathsf{false}}
        \hypo{\sigma \entails d_2 \evalsto v_2}
        \infer2[(EV-If-F)]{
          \sigma \entails
          \fif d_0 \fthen d_1 \felse d_2 \evalsto v_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto v_1}
        \infer1[(EV-Inj-L)]{
          \sigma \entails \inl d_1 \evalsto \fcaseL v_1
        }
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto v_1}
        \infer1[(EV-Inj-R)]{
          \sigma \entails \inr d_1 \evalsto \fcaseR v_1
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_0 \evalsto \fcaseL d_0'}
        \hypo{\sigma' = \sigma, x \mapsto d_0'}
        \hypo{\sigma' \entails d_1 \evalsto v_1}
        \infer3[(EV-Case-L)]{
          \sigma \entails
          \fcase d_0 \fcaseL x . d_1 \fcaseR x . d_2 \evalsto v_1
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_0 \evalsto \fcaseR d_0'}
        \hypo{\sigma' = \sigma, x \mapsto d_0'}
        \hypo{\sigma' \entails d_2 \evalsto v_2}
        \infer3[(EV-Case-R)]{
          \sigma \entails
          \fcase d_0 \fcaseL x . d_1 \fcaseR x . d_2 \evalsto v_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto v_1}
        \hypo{\sigma \entails d_2 \evalsto v_2}
        \infer2[(EV-Pair)]{
          \sigma \entails
          (d_1, d_2) \evalsto (v_1, v_2)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto (v_2, v_3)}
        \infer1[(EV-Prj-L)] {
          \sigma \entails \prl d_1 \evalsto v_2
        }
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto (v_2, v_3)}
        \infer1[(EV-Prj-R)] {
          \sigma \entails \prl d_1 \evalsto v_3
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{d_1 \evalsto \underline{n_1}}
        \hypo{d_2 \evalsto \underline{n_2}}
        \hypo{n_1 + n_2 = n}
        \infer3[(EV-Add)]{d_1 + d_2 \evalsto \underline{n}}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d_1 \evalsto \underline{n_1}}
        \hypo{\sigma \entails d_2 \evalsto \underline{n_2}}
        \hypo{n_1 \times n_2 = n}
        \infer3[(EV-Mul)]{\sigma \entails d_1 \times d_2 \evalsto \underline{n}}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d \evalsto v}
        \infer1[(E-Skip)]{\sigma \entails \fstep f \fin d \evalsto v}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma \entails d \evalsto v}
        \infer1[(E-Step)]{\sigma \entails \fskip f \fin d \evalsto v}
      \end{prooftree}
    \]
  \item \fbox{\(d \to d'\)} Expression \(d\) is transition into \(d'\).
    \[
      \begin{prooftree}
        \hypo{d_1 = [\sigma'] (\lambda x . d_3) \ival}
        \hypo{d_2 \ival}
        \infer2[(ET-Ap)]{[\sigma', x \hooksto d_2] d_3}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[(ET-Fix)]{\sigma \entails Y (\lambda x . d) \to [\sigma, x \hooksto Y (\lambda x . d)]d}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[(ET-Let)]{
          \sigma \entails
          \flet x = d_1 \fin d_2
          \to
          [\sigma, x \to d_1] d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma' \entails d \to d'}
        \infer1[(ET-Closure)]{\sigma \entails [\sigma'] d \to [\sigma'] d'}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\sigma' \entails d \to d'}
        \hypo{d' \final}
        \infer2[(ET-Closure-Opt)]{\sigma \entails [\sigma'] d \to d'}
      \end{prooftree}
    \]
  \item \fbox{\(f \matches d\)} Filter \(f\) matches expression \(d\).
    \[
      \begin{prooftree}
        \infer0[(FM-Hole)]{f \matches @}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \infer0[(FM-Wild)]{\ast \matches d}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_1 \matches d}
        \infer1[(FM-Skip)]{f_1 \matches \fskip f_2 \fin d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d}
        \infer1[(FM-Step)]{f_1 \matches \fstep f_2 \fin d}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[(FM-Var)]{x \matches x}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer2[(FM-Ap)]{f_1(f_2) \matches d_1(d_2)}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f \matches d}
        \infer1[(FM-Fun-Exact)]{\lambda x . f \matches \lambda x . d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f \matches d}
        \infer1[(FM-Fun-Wild)]{
          \lambda \ast . f \matches \lambda x . d
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer2[(FM-Let-Exact)]{\flet x = f_1 \fin f_2 \matches \flet x = d_1 \fin d_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer2[(FM-Let-Wild)]{
          \flet \ast = f_1 \fin f_2 \matches \flet x = d_1 \fin d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_0 \matches d_0}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer3[(FM-If)]{
          \fif f_0 \fthen f_1 \fthen f_2 \matches \fif d_0 \fthen d_1
          \felse d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_0 \matches d_0}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer3[(FM-Case)]{
          \fcase f_0 \fthen x . f_1 \felse y . f_2 \matches
          \fcase d_0 \fthen x . d_1 \felse y . d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_0 \matches d_0}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer3[(FM-Wild-L)]{
          \fcase f_0 \fthen \ast . f_1 \felse y . f_2 \matches
          \fcase d_0 \fthen x . d_1 \felse y . d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_0 \matches d_0}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer3[(FM-Wild-R)]{
          \fcase f_0 \fthen x . f_1 \felse \ast . f_2 \matches
          \fcase d_0 \fthen x . d_1 \felse y . d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_0 \matches d_0}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer3[(FM-Wild-A)]{
          \fcase f_0 \fthen \ast . f_1 \felse \ast . f_2 \matches
          \fcase d_0 \fthen x . d_1 \felse y . d_2
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \infer1[(FM-Inj-L)]{
          \inl f_1 \matches \inl d_1
        }
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \infer1[(FM-Inj-R)]{
          \inr f_1 \matches \inr d_1
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \infer1[(FM-Prj-L)]{
          \prl f_1 \matches \inl d_1
        }
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \infer1[(FM-Prj-R)]{
          \prr f_1 \matches \inr d_1
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{f \matches d}
        \infer1[(FM-Fix-Exact)]{Y (\lambda x . f) \matches Y (\lambda x . d)}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f \matches d}
        \infer1[(FM-Fix-Wild)]{Y (\lambda \ast . f) \matches Y (\lambda x . d)}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer0[(FM-Num)]{\underline{n} \matches \underline{n}}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer2[(FM-Add)]{f_1 + f_2 \matches d_1 + d_2}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{f_1 \matches d_1}
        \hypo{f_2 \matches d_2}
        \infer2[(FM-Mul)]{f_1 \times f_2 \matches d_1 \times d_2}
      \end{prooftree}
    \]
  \item \fbox{\(\mathcal{F}\)} Filter environment.
    \[
      \mathcal{F} \coloneqq \varnothing \mid \mathcal{F}, (f, step) \mid
      \mathcal{F}, (f, skip)
    \]
  \item \fbox{\(\mathcal{F} \steps d, \mathcal{F} \skips d\)} Expression \(d\) is marked to be stepped
    through \(\steps\) or skipped over \(\skips\) under filter \(\mathcal{F}\).
    \[
      \begin{prooftree}
        \hypo{(f, step) \in \mathcal{F}}
        \hypo{f \matches d}
        \infer2[(FE-Step)]{\mathcal{F} \steps d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{(f, skip) \in \mathcal{F}}
        \hypo{f \matches d}
        \infer2[(FE-Skip)]{\mathcal{F} \skips d}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\mathcal{F} = \mathcal{F}_1,\mathcal{F}_2}
        \hypo{\mathcal{F}_1 \skips d}
        \hypo{\mathcal{F}_2 \steps d}
        \infer3[(FE-Skip)]{\mathcal{F} \steps d}
      \end{prooftree}
      \quad
      \begin{prooftree}
        \hypo{\mathcal{F} = \mathcal{F}_1,\mathcal{F}_2}
        \hypo{\mathcal{F}_1 \steps d}
        \hypo{\mathcal{F}_2 \skips d}
        \infer3[(FE-Step)]{\mathcal{F} \skips d}
      \end{prooftree}
    \]
  \item \fbox{\(\class{EvalCtx} \mathcal{E}\)} Evaluation Context
    \[
      \begin{array}{rcll}
        \class{EvalCtx} \mathcal{E}
        &\coloneqq& \circ & \text{(Mark)}\\
        &\mid& \mathcal{E} (d) & \text{(Application, Left)} \\
        &\mid& d (\mathcal{E}) & \text{(Application, Right)} \\
        &\mid& [\sigma] \mathcal{E} & \text{(Closure)} \\
        % &\mid& \flet x = \mathcal{E} \fin d & \text{(Let Expression)} \\
        &\mid& \mathcal{E} + d & \text{(Addition, Left)} \\
        &\mid& d + \mathcal{E} & \text{(Addition, Right)} \\
        &\mid& \mathcal{E} \times d & \text{(Multiplication, Left)} \\
        &\mid& d \times \mathcal{E} & \text{(Multiplication, Right)} \\
        &\mid& \fif \mathcal{E} \fin d & \text{(Let Expression)} \\
        &\mid& (\mathcal{E}, d) & \text{(Pair, Left)} \\
        &\mid& (d, \mathcal{E}) & \text{(Pair, Right)} \\
        &\mid& \inl \mathcal{E} \mid \inr \mathcal{E} & \text{(Injection)} \\
        &\mid& \prl \mathcal{E} \mid \prr \mathcal{E} & \text{(Projection)} \\
        &\mid& \fcase \mathcal{E} \fcaseL x . d \fcaseR x . d & \text{(Case Expression)} \\
        &\mid& \fstep f \fin \mathcal{E} & \text{(Step)} \\
        &\mid& \fskip f \fin \mathcal{E} & \text{(Skip)}
      \end{array}
    \]
  % \item \fbox{\(\class{EvalOpt} \mathcal{O}\)}
  %   \[
  %     \begin{array}{rcl}
  %       \class{EvalOpt} \mathcal{O}
  %       &\coloneqq& \varnothing \\
  %       &\mid& \mathcal{O}, \mathcal{E} \{ d \}
  %     \end{array}
  %   \]
  \item \fbox{\(d =_\mathcal{F} \mathcal{E} \{ d' \}\)} Expression \(d\) can be
    obtained by placing \(d'\) at the marked position in
    \(\mathcal{E}\).
    \begin{enumerate}
      \item Filter Elimination. Add filters to the filter environment.
        \[
          \begin{prooftree}
            \hypo{\mathcal{F}' = \mathcal{F}, (f, step)}
            \hypo{
              \sigma \entails
              d =_{\mathcal{F}'} \mathcal{E} \{ d' \} \iskip
            }
            \infer2[(FA-Step-Skip)]{
              \sigma \entails
              \fstep f \fin d
              =_\mathcal{F}
              \fstep f \fin \mathcal{E} \{ d' \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\mathcal{F}' = \mathcal{F}, (f, step)}
            \hypo{
              \sigma \entails
              d =_{\mathcal{F}'} \mathcal{E} \{ d' \} \istep
            }
            \infer2[(FA-Step-Step)]{
              \sigma \entails
              \fstep f \fin d
              =_\mathcal{F}
              \fstep f \fin \mathcal{E} \{ d' \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\mathcal{F}' = \mathcal{F}, (f, skip)}
            \hypo{\sigma \entails d =_{\mathcal{F}'} \mathcal{E} \{ d' \} \iskip}
            \infer2[(FA-Skip-Skip)]{
              \sigma \entails
              \fskip f \fin d
              =_\mathcal{F}
              \fskip f \fin \mathcal{E} \{ d' \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\mathcal{F}' = \mathcal{F}, (f, skip)}
            \hypo{\sigma \entails d =_{\mathcal{F}'} \mathcal{E} \{ d' \} \istep}
            \infer2[(FA-Skip-Step)]{
              \sigma \entails
              \fskip f \fin d
              =_\mathcal{F}
              \fskip f \fin \mathcal{E} \{ d' \} \istep
            }
          \end{prooftree}
        \]

      \item Closure.
        \[
          \begin{prooftree}
            \hypo{
              \sigma' \entails
              d =_\mathcal{F} \mathcal{E} \{d'\} \iskip
            }
            \infer1{
              \sigma \entails
              [\sigma'] d
              =_\mathcal{F}
              [\sigma'] \mathcal{E} \{ d' \} \iskip
            }
          \end{prooftree}
          \quad
          \begin{prooftree}
            \hypo{
              \sigma' \entails
              d =_\mathcal{F} \mathcal{E} \{d'\} \istep
            }
            \infer1{
              \sigma \entails
              [\sigma'] d
              =_\mathcal{F}
              [\sigma'] \mathcal{E} \{ d' \} \istep
            }
          \end{prooftree}
        \]

      \item Variable, Function Literal, Fix-point.
        \[
          \begin{prooftree}
            \hypo{f \skips x}
            \infer1[(FD-Var-Skip)]{\sigma \entails x =_\mathcal{F} \circ
            \{ [\sigma]x \} \iskip}
          \end{prooftree}
          \quad
          \begin{prooftree}
            \hypo{f \steps x}
            \infer1[(FD-Var-Step)]{
              \sigma \entails
              x =_\mathcal{F} \circ \{ [\sigma]x \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{f \skips \lambda x . d}
            \infer1[(FD-Fun-Skip)]{
              \sigma \entails
              \lambda x . d
              =_\mathcal{F}
              \circ \{[\sigma](\lambda x . d)\} \iskip
            }
          \end{prooftree}
          \quad
          \begin{prooftree}
            \hypo{f \steps \lambda x . d}
            \infer1[(FD-Fun-Step)]{
              \sigma \entails
              \lambda x . d
              =_\mathcal{F}
              \circ \{[\sigma](\lambda x . d)\} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{f \skips Y (\lambda x . d)}
            \infer1[(FD-Fix-Skip)]{
              \sigma \entails
              Y (\lambda x . d)
              =_\mathcal{F}
              \circ \{ [\sigma] Y (\lambda x . d) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{f \steps Y (\lambda x . d)}
            \infer1[(FD-Fix-Step)]{
              \sigma \entails
              Y (\lambda x . d)
              =_\mathcal{F}
              \circ \{ [\sigma] (Y (\lambda x . d)) \} \istep
            }
          \end{prooftree}
        \]
      \item Function Application
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1(d_2)}
            \infer3[(FD-Ap-Skip-Z)]{
              \sigma \entails
              d_1 (d_2) =_\mathcal{F} \circ \{ [\sigma] d_1(d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{
              \sigma \entails
              d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip
            }
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1(d_2)}
            \infer3[(FD-Ap-Skip-L)]{
              \sigma \entails
              d_1 (d_2) =_\mathcal{F} \circ \{ [\sigma] d_1(d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2 \}_{\sigma_2} \iskip}
            \hypo{\mathcal{F} \skips d_1(d_2)}
            \infer3[(FD-Ap-Skip-R)]{
              \sigma \entails
              d_1 (d_2) =_\mathcal{F} \circ \{ [\sigma] d_1(d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \}_{\sigma_1} \iskip}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2 \}_{\sigma_2} \iskip}
            \hypo{\mathcal{F} \skips d_1(d_2)}
            \infer3[(FD-Ap-Skip-A)]{
              \sigma \entails
              d_1 (d_2) =_\mathcal{F} \circ \{ [\sigma] d_1(d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \infer2[(FD-Ap-Step-Z)]{
              \sigma \entails
              d_1 (d_2) =_\mathcal{F} \circ \{ [\sigma] d_1(d_2)\} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{
              \sigma \entails
              d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep
            }
            \hypo{\sigma \entails d_2 \final}
            \infer2[(FD-Ap-Step-L)]{
              \sigma \entails
              d_1(d_2)
              =_\mathcal{F}
              \mathcal{E}_1(d_2) \{ d_1' \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{
              \sigma \entails
              d_2 =_\mathcal{F} \mathcal{E}_2 \{ d_2' \} \istep
            }
            \infer2[(FD-Ap-Step-R)]{
              \sigma \entails
              d_1(d_2)
              =_\mathcal{F}
              d_1(\mathcal{E}_2) \{d_2'\} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{d_2'\} \istep}
            \infer2[(FD-Ap-Step-A)]{
              \sigma \entails
              d_1(d_2)
              =_\mathcal{F}
              \mathcal{E}_1 (d_2) \{d_1'\}, d_1(\mathcal{E}_2)\{d_2'\} \istep
            }
          \end{prooftree}
        \]

      \item Let Expression
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\mathcal{F} \skips \flet x = d_1 \fin d_2}
            \infer2[(FD-Let-Skip-Z)]{
              \sigma \entails
              \flet x = d_1 \fin d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \flet x = d_1 \fin d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip}
            \hypo{\mathcal{F} \skips \flet x = d_1 \fin d_2}
            \infer2[(FD-Let-Skip-L)]{
              \sigma \entails
              \flet x = d_1 \fin d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \flet x = d_1 \fin d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1 \} \istep}
            \infer1[(FD-Let-Step-L)]{
              \flet x = d_1 \fin d_2
              =_\mathcal{F}
              \flet x = \mathcal{E}_1 \fin \{ d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Let-Step-R)]{
              \flet x = d_1 \fin d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \flet x = d_1 \fin d_2 \} \istep
            }
          \end{prooftree}
        \]

      \item If Expression
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_0 \final}
            \hypo{\mathcal{F} \skips \fif d_0 \fthen d_1 \felse d_2}
            \infer2[(FD-If-Skip-Z)]{
              \sigma \entails
              \fif d_0 \fthen d_1 \felse d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fif d_0 \fthen d_1 \felse d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_0 =_\mathcal{F} \circ \{ d_0' \} \iskip}
            \hypo{\mathcal{F} \skips \fif d_0 \fthen d_1 \fin d_2}
            \infer2[(FD-If-Skip-L)]{
              \sigma \entails
              \fif d_0 \fthen d_1 \felse d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fif d_0 \fthen d_1 \felse d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_0 =_\mathcal{F} \mathcal{E}_0 \{ d_0 \} \istep}
            \infer1[(FD-If-Step-L)]{
              \fif d_0 \fthen d_1 \felse d_2
              =_\mathcal{F}
              \fif \mathcal{E}_0 \fthen d_1 \felse d_2 \{ d_0 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_0 \final}
            \infer1[(FD-If-Step-R)]{
              \fif d_0 \fthen d_1 \felse d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fif d_0 \fthen d_1 \felse d_2 \} \istep
            }
          \end{prooftree}
        \]

      \item Case Expression
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_0 \final}
            \hypo{\mathcal{F} \skips \fcase d_0 \fcaseL d_1 \fcaseR d_2}
            \infer2[(FD-Case-Skip-Z)]{
              \sigma \entails
              \fcase d_0 \fcaseL d_1 \fcaseR d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fcase d_0 \fcaseL d_1 \fcaseR d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_0 =_\mathcal{F} \circ \{ d_0' \} \iskip}
            \hypo{\mathcal{F} \skips \fcase d_0 \fcaseL d_1 \fcaseR d_2}
            \infer2[(FD-Case-Skip-L)]{
              \sigma \entails
              \fcase d_0 \fcaseL d_1 \fcaseR d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fcase d_0 \fcaseL d_1 \fcaseR d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_0 =_\mathcal{F} \mathcal{E}_{0} \{ d_0 \} \istep}
            \infer1[(FD-Case-Step-L)]{
              \fcase d_0 \fcaseL d_1 \fcaseR d_2
              =_\mathcal{F}
              \fcase \mathcal{E}_{0} \fcaseL d_1 \fcaseR d_2 \{ d_0 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Case-Step-R)]{
              \fcase d_0 \fcaseL d_1 \fcaseR d_2
              =_\mathcal{F}
              \circ \{ [\sigma] \fcase d_0 \fcaseL d_1 \fcaseR d_2 \} \istep
            }
          \end{prooftree}
        \]

      \item Injection
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\mathcal{F} \skips \inl d_1}
            \infer2[(FD-Inj-L-Skip-Z)]{
              \sigma \entails
              \inl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inl d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip}
            \hypo{\mathcal{F} \skips \inl d_1}
            \infer2[(FD-Inj-L-Skip-L)]{
              \sigma \entails
              \inl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inl d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1 \} \istep}
            \infer1[(FD-Inj-L-Step-L)]{
              \inl d_1
              =_\mathcal{F}
              \inl \mathcal{E}_1 \{ d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Inj-L-Step-R)]{
              \inl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inl d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\mathcal{F} \skips \inr d_1}
            \infer2[(FD-Inj-R-Skip-Z)]{
              \sigma \entails
              \inr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inr d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip}
            \hypo{\mathcal{F} \skips \inr d_1}
            \infer2[(FD-Inj-R-Skip-L)]{
              \sigma \entails
              \inr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inr d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1 \} \istep}
            \infer1[(FD-Inj-R-Step-L)]{
              \inr d_1
              =_\mathcal{F}
              \inr \mathcal{E}_1 \{ d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Inj-R-Step-R)]{
              \inr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \inr d_1 \} \istep
            }
          \end{prooftree}
        \]

      \item Projection
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\mathcal{F} \skips \prl d_1}
            \infer2[(FD-Prj-L-Skip-Z)]{
              \sigma \entails
              \prl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prl d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip}
            \hypo{\mathcal{F} \skips \prl d_1}
            \infer2[(FD-Prj-L-Skip-L)]{
              \sigma \entails
              \prl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prl d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1 \} \istep}
            \infer1[(FD-Prj-L-Step-L)]{
              \prl d_1
              =_\mathcal{F}
              \prl \mathcal{E}_1 \{ d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Prj-L-Step-R)]{
              \prl d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prl d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\mathcal{F} \skips \prr d_1}
            \infer2[(FD-Prj-R-Skip-Z)]{
              \sigma \entails
              \prr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prr d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1 \} \iskip}
            \hypo{\mathcal{F} \skips \prr d_1}
            \infer2[(FD-Prj-R-Skip-L)]{
              \sigma \entails
              \prr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prr d_1 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1 \} \istep}
            \infer1[(FD-Prj-R-Step-L)]{
              \prr d_1
              =_\mathcal{F}
              \prr \mathcal{E}_1 \{ d_1 \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{d_1 \final}
            \infer1[(FD-Prj-R-Step-R)]{
              \prr d_1
              =_\mathcal{F}
              \circ \{ [\sigma] \prr d_1 \} \istep
            }
          \end{prooftree}
        \]

      \item Product
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips (d_1, d_2)}
            \infer3[(FD-Add-Skip-Z)]{
              \sigma \entails (d_1, d_2) =_\mathcal{F} \circ \{ [\sigma] (d_1, d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip }
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips (d_1, d_2)}
            \infer3[(FD-Add-Skip-L)]{
              \sigma \entails
              (d_1, d_2) =_\mathcal{F} \circ \{ [\sigma] (d_1, d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip }
            \hypo{\mathcal{F} \skips (d_1, d_2)}
            \infer3[(FD-Add-Skip-R)]{
              \sigma \entails
              (d_1, d_2) =_\mathcal{F} \circ \{ [\sigma] (d_1, d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip}
            \hypo{\mathcal{F} \skips (d_1, d_2)}
            \infer3[(FD-Add-Skip-A)]{
              \sigma \entails
              (d_1, d_2) =_\mathcal{F} \circ \{ [\sigma] (d_1, d_2) \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \infer2[(FD-Add-Step-Z)]{
              \sigma \entails
              (d_1, d_2) =_\mathcal{F} \circ \{ [\sigma] (d_1, d_2)\} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 = \final}
            \infer2[(FD-Add-Step-L)]{
              \sigma \entails
              (d_1, d_2)
              =_\mathcal{F}
              (\mathcal{E}_1, d_2) \{ d_1' \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{ d_2' \} \istep}
            \infer2[(FD-Add-Step-R)]{\sigma \entails (d_1, d_2) =_\mathcal{F} d_1 + \mathcal{E}_2 \{ d_2'
            \} \istep}
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{d_2'\} \istep}
            \infer2[(FD-Add-Step-A)]{
              \sigma \entails
              (d_1, d_2)
              =_\mathcal{F}
              (\mathcal{E}_1, d_2) \{d_1'\}, (d_1, \mathcal{E}_2)\{d_2'\} \istep
            }
          \end{prooftree}
        \]
      \item Addition
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1 + d_2}
            \infer3[(FD-Add-Skip-Z)]{
              \sigma \entails d_1 + d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 + d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip }
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1 + d_2}
            \infer3[(FD-Add-Skip-L)]{
              \sigma \entails
              d_1 + d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 + d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip }
            \hypo{\mathcal{F} \skips d_1 + d_2}
            \infer3[(FD-Add-Skip-R)]{
              \sigma \entails
              d_1 + d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 + d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip}
            \hypo{\mathcal{F} \skips d_1 + d_2}
            \infer3[(FD-Add-Skip-A)]{
              \sigma \entails
              d_1 + d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 + d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \infer2[(FD-Add-Step-Z)]{
              \sigma \entails
              d_1 + d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 + d_2\} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 = \final}
            \infer2[(FD-Add-Step-L)]{
              \sigma \entails
              d_1 + d_2
              =_\mathcal{F}
              \mathcal{E}_1 + d_2 \{ d_1' \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{ d_2' \} \istep}
            \infer2[(FD-Add-Step-R)]{\sigma \entails d_1 + d_2 =_\mathcal{F} d_1 + \mathcal{E}_2 \{ d_2'
            \} \istep}
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{d_2'\} \istep}
            \infer2[(FD-Add-Step-A)]{
              \sigma \entails
              d_1 + d_2
              =_\mathcal{F}
              \mathcal{E}_1 + d_2 \{d_1'\}, d_1 + \mathcal{E}_2\{d_2'\} \istep
            }
          \end{prooftree}
        \]
      \item Multiplication
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1 \times d_2}
            \infer3[(FD-Mul-Skip-Z)]{
              \sigma \entails d_1 \times d_2 =_\mathcal{F} \circ \{ [\sigma] d_1 \times d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip }
            \hypo{\sigma \entails d_2 \final}
            \hypo{\mathcal{F} \skips d_1 \times d_2}
            \infer3[(FD-Mul-Skip-L)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \circ \{ [\sigma] d_1 \times d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip }
            \hypo{\mathcal{F} \skips d_1 \times d_2}
            \infer3[(FD-Mul-Skip-R)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \circ \{ [\sigma] d_1 \times d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \circ \{ d_1' \} \iskip}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \circ \{ d_2' \} \iskip}
            \hypo{\mathcal{F} \skips d_1 \times d_2}
            \infer3[(FD-Mul-Skip-A)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \circ \{ [\sigma] d_1 \times d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 \final}
            \infer2[(FD-Mul-Step-Z)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \circ \{ [\sigma] d_1 \times d_2 \} \iskip
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 = \final}
            \infer2[(FD-Mul-Step-L)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \mathcal{E}_1 \times d_2 \{ d_1' \} \istep
            }
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 \final}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{ d_2' \} \istep}
            \infer2[(FD-Mul-Step-R)]{\sigma \entails d_1 \times d_2 =_\mathcal{F} d_1 \times \mathcal{E}_2 \{ d_2'
            \} \istep}
          \end{prooftree}
        \]
        \[
          \begin{prooftree}
            \hypo{\sigma \entails d_1 =_\mathcal{F} \mathcal{E}_1 \{ d_1' \} \istep}
            \hypo{\sigma \entails d_2 =_\mathcal{F} \mathcal{E}_2 \{d_2'\} \istep}
            \infer2[(FD-Mul-Step-A)]{
              \sigma \entails
              d_1 \times d_2
              =_\mathcal{F}
              \mathcal{E}_1 \times d_2 \{d_1'\}, d_1 \times \mathcal{E}_2\{d_2'\} \istep
            }
          \end{prooftree}
        \]
    \end{enumerate}
  \item \fbox{\(d \mapsto d'\)} Expression \(d\) steps to expression
    \(d'\).
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d =_\mathcal{F} \mathcal{E} \{ d_0 \} \istep}
        \hypo{d_0 \to d_0'}
        \hypo{\sigma \entails d' = \mathcal{E} \{ d_0' \}}
        \infer3[(FS-Step)]{\sigma \entails d \mapsto_\mathcal{F} d'}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\sigma \entails d =_\mathcal{F} \mathcal{E} \{ d_0 \} \iskip}
        \hypo{d_0 \evalsto d_0'}
        \hypo{\sigma \entails d' = \mathcal{E} \{ d_0' \}}
        \infer3[(FS-Skip)]{\sigma \entails d \mapsto_\mathcal{F} d'}
      \end{prooftree}
    \]
\end{enumerate}

\section{Example Derivation}

\begin{enumerate}
  \item Skip addition. For \(\mathcal{F} = (\ast, step), (\ast \times \ast, skip)\),
    \[
      \mathcal{D}_1 = \begin{prooftree}
        \hypo{1 \final}
        \hypo{2 \final}
        \hypo{\mathcal{F} \skips 1 \times 2}
        \infer3{1 \times 2 =_\mathcal{F} \circ \{ 1 \times 2 \} \iskip}
        \hypo{3 \final}
        \hypo{\mathcal{F} \skips (1 \times 2) \times 3}
        \infer3{
          1 \times 2 \times 3
          =_\mathcal{F}
          \circ \{ 1 \times 2 \times 3 \} \iskip
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\mathcal{D}_1}
        \hypo{1 \times 2 \times 3 \evalsto 6}
        \hypo{6 = \circ \{ 6 \}}
        \infer3{
          1 \times 2 \times 3 \mapsto_\mathcal{F} 6
        }
      \end{prooftree}
    \]

  \item Skip Multiplication. For \(\mathcal{F} = (\ast, skip), (\ast + \ast, step)\),
    \[
      \mathcal{D}_2 = \begin{prooftree}
        \hypo{1 \final}
        \hypo{2 \final}
        \hypo{\mathcal{F} \steps 1 + 2}
        \infer3{1 + 2 =_\mathcal{F} \circ \{ 1 + 2 \} \istep}
        \hypo{3 \final}
        \infer2{1 + 2 + 3 =_\mathcal{F} \circ + 3 \{ 1 + 2 \} \istep}
        \hypo{4 \final}
        \infer2{(1 + 2 + 3) \times 4 =_\mathcal{F} (\circ + 3) \times 4 \{ 1 + 2 \} \istep}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\mathcal{D}_2}
        \hypo{1 + 2 \to 3}
        \hypo{(3 + 3) \times 4 = (\circ + 3) \times 4 \{ 3 \}}
        \infer3{(1 + 2 + 3) \times 4 \mapsto_\mathcal{F} (3 + 3) \times 4}
      \end{prooftree}
    \]

  \item Skips multiplication, but steps through addition, i.e.
    \[
      \mathcal{F} = (\ast, skip), (\ast + \ast, step)
    \]
    \[
      \begin{array}{lcrcl}
        & & \varnothing &\entails& (1 + 2 + 3) \times 4 \times 5 \\
        &\mapsto& \varnothing &\entails& (3 + 3) \times 4 \times 5 \\
        &\mapsto& \varnothing &\entails& 6 \times 4 \times 5 \\
        &\mapsto& \varnothing &\entails& 120
      \end{array}
    \]

  \item Debug a recursive function.
    \begin{align*}
      \sigma_f &= f \hooksto Y (\lambda f . \lambda x . \fstep \ast \fin
      f(x + 1)),\\
      \sigma_{fx} &= \sigma_f, x \hooksto 0.
    \end{align*}
    \[
      \begin{array}{lcrcl}
        & & \varnothing &\entails& (Y (\lambda f . \lambda x . \fstep \ast \fin f(x + 1))) (0) \\
        &\mapsto& \varnothing &\entails& ([\sigma_f] (\lambda x . \fstep \ast \fin f(x + 1))) (0) \\
        &\mapsto& \sigma_{fx} &\entails& \fstep \ast \fin f(x + 1) \\
        &\mapsto& \sigma_{fx} &\entails& \fstep \ast \fin f(0 + 1) \\
        &\mapsto& \sigma_{fx} &\entails& \fstep \ast \fin f(1)\\
        &\mapsto& \sigma_{fx} &\entails&
        \fstep \ast \fin (Y (\lambda f . \lambda x . \fstep \ast \fin f(x + 1))) (1) \\
        &\mapsto& \sigma_{fx} &\entails&
        \fstep \ast \fin [\sigma_f] (\lambda x . \fstep \ast \fin f(x + 1)) (1) \\
        &\mapsto& \sigma_{fx} &\entails&
        \fstep \ast \fin [\sigma_{fx}] \fstep \ast \fin f(x + 1) \\
        &\mapsto& \ldots
      \end{array}
    \]
\end{enumerate}

\section{Filter, but Typed}

\begin{enumerate}
  \item
    \[
      \begin{prooftree}
        \hypo{\Gamma, x : V \tau \entails d \synth E \tau}
        \infer1[]{\Gamma \entails \lambda x : \tau . d \synth E (V \tau \to E \tau)}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \Gamma \entails
          \lambda x : \tau . d
          \synth E (V \tau \to E \tau)
        }
        \infer1[]{
          \Gamma \entails [\sigma] (\lambda x : \tau . d)
          \synth
          V (V \tau \to E \tau)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth V \tau}
        \hypo{\tau \MatchArrow V \tau_1 \to E \tau_2}
        \hypo{\Gamma \entails d_2 \analyze V \tau_1}
        \infer3[]{\Gamma \entails d_1 d_2 \synth E \tau_2}
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{\Gamma \entails d_1 \synth E \tau}
        \hypo{\tau \MatchArrow V \tau_1 \to E \tau_2}
        \hypo{\Gamma \entails d_2 \analyze V \tau_1}
        \infer3[]{\Gamma \entails d_1 d_2 \synth E \tau_2}
      \end{prooftree}
    \]
\end{enumerate}

\end{document}
