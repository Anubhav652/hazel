open Sexplib.Std;

module rec Typ: {
  /* TYPE_PROVENANCE: From whence does an unknown type originate?
     Is it generated from an unannotated pattern variable (SynSwitch),
     a pattern variable annotated with a type hole (TypeHole), or
     generated by an internal judgement (Internal)? */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type type_provenance =
    | SynSwitch
    | TypeHole
    | Internal;

  /* TYP.T: Hazel types */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type t =
    | Unknown(type_provenance)
    | Int
    | Float
    | Bool
    | String
    | Var(Token.t)
    | List(t)
    | Arrow(t, t)
    | Sum(sum_map)
    | Prod(list(t))
    | Rec(Token.t, t)
  and sum_map = VarMap.t_(option(t));

  [@deriving (show({with_path: false}), sexp, yojson)]
  type sum_entry = (Token.t, option(t));

  /* SOURCE: Hazel type annotated with a relevant source location.
     Currently used to track match branches for inconsistent
     branches errors, but could perhaps be used more broadly
     for type debugging UI. */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type source = {
    id: int,
    ty: t,
  };

  [@deriving (show({with_path: false}), sexp, yojson)]
  type self_error =
    | Multi
    | NoFun(t)
    | Free
    | FreeTag;

  /* SELF: The (synthetic) type information derivable from a term
     in isolation, using the typing context but not the syntactic
     context. This can either be Free (no type, in the case of
     unbound/undefined names), Joined (a list of types, possibly
     inconsistent, generated by branching forms like ifs,
     matches, and list literals), or Just a regular type. */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type self =
    | Just(t)
    // TODO: make joined apply only to inconsistent types; rename NoJoin, move to Self
    | Joined(t => t, list(source))
    | Self(self_error);

  /* MODE: The (analytic) type information derived from a term's
     syntactic context. This can either Syn (no type expectation),
     or Ana (a type expectation). It is conjectured [citation needed]
     that the Syn mode is functionally indistinguishable from
     Ana(Unknown(SynSwitch)), and that this type is thus vestigial. */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type mode =
    | SynFun
    | Syn
    | Ana(t);
} = {
  [@deriving (show({with_path: false}), sexp, yojson)]
  type type_provenance =
    | SynSwitch
    | TypeHole
    | Internal;

  /* TYP.T: Hazel types */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type t =
    | Unknown(type_provenance)
    | Int
    | Float
    | Bool
    | String
    | Var(Token.t)
    | List(t)
    | Arrow(t, t)
    | Sum(sum_map)
    | Prod(list(t))
    | Rec(Token.t, t)
  and sum_map = VarMap.t_(option(t));

  [@deriving (show({with_path: false}), sexp, yojson)]
  type sum_entry = (Token.t, option(t));

  [@deriving (show({with_path: false}), sexp, yojson)]
  type source = {
    id: int,
    ty: t,
  };

  [@deriving (show({with_path: false}), sexp, yojson)]
  type self_error =
    | Multi
    | NoFun(t)
    | Free
    | FreeTag;

  [@deriving (show({with_path: false}), sexp, yojson)]
  type self =
    | Just(t)
    | Joined(t => t, list(source))
    | Self(self_error);

  [@deriving (show({with_path: false}), sexp, yojson)]
  type mode =
    | SynFun
    | Syn
    | Ana(t);
}
and Ctx: {
  [@deriving (show({with_path: false}), sexp, yojson)]
  type var_entry = {
    name: Token.t,
    id: Id.t,
    typ: Typ.t,
  };

  [@deriving (show({with_path: false}), sexp, yojson)]
  type entry =
    | VarEntry(var_entry)
    | TagEntry(var_entry)
    | TVarEntry({
        name: Token.t,
        id: Id.t,
        kind: Kind.t,
      });

  [@deriving (show({with_path: false}), sexp, yojson)]
  type t = list(entry);

  [@deriving (show({with_path: false}), sexp, yojson)]
  type co_entry = {
    id: Id.t,
    mode: Typ.mode,
  };

  /* Each co-context entry is a list of the uses of a variable
     within some scope, including their type demands */
  [@deriving (show({with_path: false}), sexp, yojson)]
  type co = VarMap.t_(list(co_entry));
} = {
  [@deriving (show({with_path: false}), sexp, yojson)]
  type var_entry = {
    name: Token.t,
    id: Id.t,
    typ: Typ.t,
  };

  [@deriving (show({with_path: false}), sexp, yojson)]
  type entry =
    | VarEntry(var_entry)
    | TagEntry(var_entry)
    | TVarEntry({
        name: Token.t,
        id: Id.t,
        kind: Kind.t,
      });

  [@deriving (show({with_path: false}), sexp, yojson)]
  type t = list(entry);

  [@deriving (show({with_path: false}), sexp, yojson)]
  type co_entry = {
    id: Id.t,
    mode: Typ.mode,
  };

  [@deriving (show({with_path: false}), sexp, yojson)]
  type co = VarMap.t_(list(co_entry));
}
and Kind: {
  [@deriving (show({with_path: false}), sexp, yojson)]
  type t =
    | Singleton(Typ.t)
    | Abstract;
} = {
  [@deriving (show({with_path: false}), sexp, yojson)]
  type t =
    | Singleton(Typ.t)
    | Abstract;
};
