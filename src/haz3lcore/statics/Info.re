open Sexplib.Std;
open Util.OptUtil.Syntax;

/* SOURCE: Hazel type annotated with a relevant source location.
   Currently used to track match branches for inconsistent
   branches errors, but could perhaps be used more broadly
   for type debugging UI. */
[@deriving (show({with_path: false}), sexp, yojson)]
type source = {
  id: int,
  ty: Typ.t,
};

/* SELF: The (synthetic) type information derivable from a term
   in isolation, using the typing context but not the syntactic
   context. This can either be Free (no type, in the case of
   unbound/undefined names), Joined (a list of types, possibly
   inconsistent, generated by branching forms like ifs,
   matches, and list literals), or Just a regular type. */
[@deriving (show({with_path: false}), sexp, yojson)]
type self =
  | Just(Typ.t)
  | SelfVar(Token.t) //TODO: exp only
  | SelfTag(Token.t)
  | SelfMultiHole
  | NoJoin(list(source));

/* Expressions are assigned a mode (reflecting the static expectations
   if any of their syntactic parent), a self (reflecting what their
   statics would be in isolation), a context (variables in scope), and
   free (variables occuring free in the expression. */
[@deriving (show({with_path: false}), sexp, yojson)]
type info_exp = {
  cls: Term.UExp.cls,
  term: Term.UExp.t,
  mode: Typ.mode,
  self,
  ctx: Ctx.t,
  free: Ctx.co,
};

/* Patterns are assigned a mode (reflecting the static expectations
   if any of their syntactic parent) and a self (reflecting what their
   statics would be in isolation), a context (variables in scope) */
[@deriving (show({with_path: false}), sexp, yojson)]
type info_pat = {
  cls: Term.UPat.cls,
  term: Term.UPat.t,
  mode: Typ.mode,
  self,
  ctx: Ctx.t,
};

[@deriving (show({with_path: false}), sexp, yojson)]
type status_variant =
  | Unique
  | Duplicate;

[@deriving (show({with_path: false}), sexp, yojson)]
type typ_mode =
  | TypeExpected
  | TagExpected(status_variant)
  | VariantExpected(status_variant);

[@deriving (show({with_path: false}), sexp, yojson)]
type self_typ =
  | EmptyHole /* can be either type or variant */
  | Type(Typ.t)
  | Tag(Token.t)
  | Ap;

/* A type can be either valid or a free type variable.
   The additional errors statuses are fundamentally
   syntactic and should eventually be reimplemeted
   via a seperate sort */
[@deriving (show({with_path: false}), sexp, yojson)]
type error_typ =
  | FreeTypeVar
  | DuplicateTag
  | ApOutsideSum
  | TagExpected;

[@deriving (show({with_path: false}), sexp, yojson)]
type happy_typ =
  | Variant
  | Type(Typ.t);

[@deriving (show({with_path: false}), sexp, yojson)]
type status_typ =
  | InHole(error_typ)
  | NotInHole(happy_typ);

[@deriving (show({with_path: false}), sexp, yojson)]
type info_typ = {
  cls: Term.UTyp.cls,
  term: Term.UTyp.t,
  mode: typ_mode,
  ctx: Ctx.t,
  self: self_typ,
};

[@deriving (show({with_path: false}), sexp, yojson)]
type info_rul = {
  cls: Term.URul.cls,
  term: Term.UExp.t,
};

[@deriving (show({with_path: false}), sexp, yojson)]
type error_tpat =
  | NotAVar;

[@deriving (show({with_path: false}), sexp, yojson)]
type status_tpat =
  | NotInHole(Token.t)
  | InHole(error_tpat);

[@deriving (show({with_path: false}), sexp, yojson)]
type self_tpat =
  | Var(Token.t)
  | NotAVar;

[@deriving (show({with_path: false}), sexp, yojson)]
type info_tpat = {
  cls: Term.UTPat.cls,
  term: Term.UTPat.t,
  self: self_tpat,
};

/* The Info aka Cursorinfo assigned to each subterm. */
[@deriving (show({with_path: false}), sexp, yojson)]
type t =
  | Invalid(TermBase.parse_flag)
  | InfoExp(info_exp)
  | InfoPat(info_pat)
  | InfoTyp(info_typ)
  | InfoRul(info_rul)
  | InfoTPat(info_tpat);

/* Static error classes */
[@deriving (show({with_path: false}), sexp, yojson)]
type error_common =
  | NoFun(Typ.t)
  | FreeVar
  | FreeTag
  | SynInconsistentBranches(list(Typ.t))
  | TypeInconsistent(Typ.t, Typ.t);

/* Statics non-error classes */
[@deriving (show({with_path: false}), sexp, yojson)]
type happy_common =
  | SynConsistent(Typ.t)
  | AnaConsistent(Typ.t, Typ.t, Typ.t)
  | AnaInternalInconsistent(Typ.t, list(Typ.t));

[@deriving (show({with_path: false}), sexp, yojson)]
type error_exp = error_common;

/*
 [@deriving (show({with_path: false}), sexp, yojson)]
 type error_exp =
   | NoFun(Typ.t)
   | FreeVar
   | Common(error_common);

  [@deriving (show({with_path: false}), sexp, yojson)]
  type happy_exp = happy_common;

  [@deriving (show({with_path: false}), sexp, yojson)]
  type error_pat = error_common;

  [@deriving (show({with_path: false}), sexp, yojson)]
  type happy_pat = happy_common;

  [@deriving (show({with_path: false}), sexp, yojson)]
  type status_exp =
    | InHole(error_exp)
    | NotInHole(happy_exp);

  [@deriving (show({with_path: false}), sexp, yojson)]
  type status_pat =
    | InHole(error_pat)
    | NotInHole(happy_common);*/

[@deriving (show({with_path: false}), sexp, yojson)]
type status_common =
  | InHole(error_common)
  | NotInHole(happy_common);

/* Strip location information from a list of sources */
let source_tys = List.map((source: source) => source.ty);

let typ_of_self: (Ctx.t, self) => Typ.t =
  ctx =>
    fun
    | Just(ty) => ty
    | SelfVar(name) =>
      switch (Ctx.lookup_var(ctx, name)) {
      | None => Unknown(Internal)
      | Some({typ, _}) => typ
      }
    | SelfTag(tag) =>
      switch (Ctx.lookup_tag(ctx, tag)) {
      | None => Unknown(Internal)
      | Some(syn) => syn.typ
      }
    | SelfMultiHole
    | NoJoin(_) => Unknown(Internal);

/* Determines whether an expression or pattern is in an error hole,
   depending on the mode, which represents the expectations of the
   surrounding syntactic context, and the self which represents the
   makeup of the expression / pattern itself. */
let rec status_common =
        (ctx: Ctx.t, mode: Typ.mode, self: self): status_common =>
  switch (self, mode) {
  | (SelfMultiHole, Syn | SynFun | Ana(_)) =>
    NotInHole(SynConsistent(Unknown(Internal)))
  | (Just(ty), Syn) => NotInHole(SynConsistent(ty))
  | (Just(ty), SynFun) =>
    switch (Typ.join(ctx, Arrow(Unknown(Internal), Unknown(Internal)), ty)) {
    | None => InHole(NoFun(ty))
    | Some(_) => NotInHole(SynConsistent(ty))
    }
  | (Just(ty_syn), Ana(ty_ana)) =>
    switch (Typ.join(ctx, ty_ana, ty_syn)) {
    | None => InHole(TypeInconsistent(ty_syn, ty_ana))
    | Some(ty_join) => NotInHole(AnaConsistent(ty_ana, ty_syn, ty_join))
    }
  | (SelfVar(name), _) =>
    switch (Ctx.lookup_var(ctx, name)) {
    | None => InHole(FreeVar)
    | Some({typ, _}) => status_common(ctx, mode, Just(typ))
    }
  | (SelfTag(tag), _) =>
    /* If a tag is being analyzed against (an arrow type returning)
       a sum type having that tag as a variant, its self type is
       considered to be determined by the sum type; otherwise,
       check the context for the tag's type */
    switch (Typ.tag_ana_typ(ctx, mode, tag)) {
    | Some(ana_ty) => status_common(ctx, mode, Just(ana_ty))
    | _ =>
      switch (Ctx.lookup_tag(ctx, tag)) {
      | Some(syn) => status_common(ctx, mode, Just(syn.typ))
      | None => InHole(FreeTag)
      }
    }
  | (NoJoin(tys), Syn | SynFun) =>
    InHole(SynInconsistentBranches(source_tys(tys)))
  | (NoJoin(tys), Ana(ty_ana)) =>
    NotInHole(AnaInternalInconsistent(ty_ana, source_tys(tys)))
  };

let self_typ = (ctx: Ctx.t, utyp: Term.UTyp.t): self_typ => {
  let ty = Term.UTyp.to_typ(ctx, utyp);
  switch (utyp.term) {
  | Tag(name) => Tag(name)
  | Ap(_, _) => Ap
  | _ => Type(ty)
  };
};

let status_typ = (ctx: Ctx.t, mode: typ_mode, self: self_typ): status_typ =>
  switch (self, mode) {
  | (EmptyHole, _) => NotInHole(Type(Unknown(Internal)))
  | (Type(ty), TypeExpected) => NotInHole(Type(ty))
  | (Type(_), TagExpected(_) | VariantExpected(_)) => InHole(TagExpected)
  | (Tag(name), _) =>
    switch (mode) {
    | VariantExpected(Duplicate)
    | TagExpected(Duplicate) => InHole(DuplicateTag)
    | VariantExpected(Unique)
    | TagExpected(Unique) => NotInHole(Variant)
    | TypeExpected =>
      Ctx.is_alias(ctx, name) ? NotInHole(Variant) : InHole(FreeTypeVar)
    }
  | (Ap, _) =>
    switch (mode) {
    | VariantExpected(_) => NotInHole(Variant)
    | TagExpected(_) => InHole(TagExpected)
    | TypeExpected => InHole(ApOutsideSum)
    }
  };

let self_tpat = (utpat: Term.UTPat.t): self_tpat =>
  switch (utpat.term) {
  | Var(name) => Var(name)
  | _ => NotAVar
  };

let status_tpat = (self: self_tpat): status_tpat =>
  switch (self) {
  | Var(name) => NotInHole(name)
  | NotAVar => InHole(NotAVar)
  };

/* Determines whether any term is in an error hole. */
let is_error = (ci: t): bool => {
  switch (ci) {
  | Invalid(Secondary) => false
  | Invalid(_) => true
  | InfoExp({mode, self, ctx, _})
  | InfoPat({mode, self, ctx, _}) =>
    switch (status_common(ctx, mode, self)) {
    | InHole(_) => true
    | NotInHole(_) => false
    }
  | InfoTyp({mode, self, ctx, _}) =>
    switch (status_typ(ctx, mode, self)) {
    | InHole(_) => true
    | NotInHole(_) => false
    }
  | InfoTPat({self, _}) =>
    switch (status_tpat(self)) {
    | InHole(_) => true
    | NotInHole(_) => false
    }
  | InfoRul(_) => false
  };
};

/* Determined the type of an expression or pattern 'after hole wrapping';
   that is, all ill-typed terms are considered to be 'wrapped in
   non-empty holes', i.e. assigned Unknown type. */
let typ_after_fix = (ctx, mode: Typ.mode, self: self): Typ.t =>
  switch (status_common(ctx, mode, self)) {
  | InHole(_) => Unknown(Internal)
  | NotInHole(SynConsistent(t)) => t
  | NotInHole(AnaConsistent(_, _, ty_join)) => ty_join
  | NotInHole(AnaInternalInconsistent(ty_ana, _)) => ty_ana
  };

let typ_after_fix_opt = (ctx, info: t): option(Typ.t) =>
  switch (info) {
  | InfoExp({mode, self, _})
  | InfoPat({mode, self, _}) => Some(typ_after_fix(ctx, mode, self))
  | InfoTyp(_)
  | InfoRul(_)
  | InfoTPat(_)
  | Invalid(_) => None
  };

let typ_of_self_opt = (ctx: Ctx.t, info: t): option(Typ.t) =>
  switch (info) {
  | InfoExp({self, _})
  | InfoPat({self, _}) => Some(typ_of_self(ctx, self))
  | InfoTyp(_)
  | InfoRul(_)
  | InfoTPat(_)
  | Invalid(_) => None
  };

let get_binding_site = (info: t): option(Id.t) => {
  switch (info) {
  | InfoExp({term: {term: Var(name) | Tag(name), _}, ctx, _})
  | InfoPat({term: {term: Tag(name), _}, ctx, _})
  | InfoTyp({term: {term: Var(name), _}, ctx, _}) =>
    let+ entry = Ctx.lookup(ctx, name);
    Ctx.get_id(entry);
  | _ => None
  };
};
